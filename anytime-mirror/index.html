<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Anytime Mirror / いつでもミラー</title>
<script>
  'use strict';
  document.documentElement.setAttribute(
    'lang', /^ja(-JP)?$/i.test(navigator.language) ? 'ja' : 'en'
  );
  document.documentElement.setAttribute(
    'data-device', /(iPhone|iPad|iPod|Android)/i.test(navigator.userAgent) ? 'sp' : 'pc'
  );
  document.title = {
    en: 'Anytime Mirror',
    ja: 'いつでもミラー'
  }[document.documentElement.lang];
  if (location.protocol == 'https:' && 'serviceWorker' in navigator) {
    navigator.serviceWorker.register('./service-worker.js');
    document.write({
      en: '<link rel="manifest" href="./manifest.json">',
      ja: '<link rel="manifest" href="./manifest-ja.json">'
    }[document.documentElement.lang]);
    document.write('<link rel="apple-touch-icon" href="./icons/icon-180x180.png">');
  }
</script>
<style>
  html {
    background-color: rgb(17,119,184);
  }
  html:not([lang="en"]) [lang="en"], html:not([lang="ja"]) [lang="ja"] {
    display: none;
  }
  html:not([data-device="pc"]) .pc, html:not([data-device="sp"]) .sp {
    display: none;
  }
  .hidden {
    display: none;
  }
</style>
<div class="hidden">
  <div id="about-this-app-content">
    <h1>
      <span lang="en">Anytime Mirror - Version 0.0</span>
      <span lang="ja">いつでもミラー - Version 0.0</span>
    </h1>
    <div>Copyright 2020 しかく<a href="https://twitter.com/shikaku1068/">@shikaku1068</a></div>
    <div>Released under <a href="https://opensource.org/licenses/mit-license.php">the MIT license</a>.</div>
    <h2>
      <span lang="en">Update History</span>
      <span lang="ja">更新履歴</span>
    </h2>
    <dl>
      <dt>1.0</dt>
      <dd>Nov X, 2020</dd>
      <dd>Initial release.</dd>
    </dl>
  </div>
  <div id="help-content">
    <h2>
      <span lang="en">How to Control</span>
      <span lang="ja">操作方法</span>
    </h2>
    <h3>
      <span lang="en">Use a Touchscreen</span>
      <span lang="ja">タッチスクリーンによる操作</span>
    </h3>
    <ul>
      <li>
        <span lang="en"><strong>Tap</strong> to pause or unpause the video.</span>
        <span lang="ja"><strong>タップ</strong>：映像を一時停止／再開する。</span>
      </li>
      <li>
        <span lang="en"><strong>Double-Tap</strong> to hide or show the video.</span>
        <span lang="ja"><strong>ダブルタップ</strong>：映像を隠す／再表示する。</span>
      </li>
      <li>
        <span lang="en"><strong>Swipe</strong> to shift the video.</span>
        <span lang="ja"><strong>スワイプ</strong>：映像の位置をずらす。</span>
      </li>
      <li>
        <span lang="en"><strong>Double-Tap and Swipe Up/Down</strong> to enlarge or reduce the video.</span>
        <span lang="ja"><strong>ダブルタップ＋上下にスワイプ</strong>：映像を拡大／縮小する。</span>
      </li>
    </ul>
    <h3>
      <span lang="en">Use a Mouse</span>
      <span lang="ja">マウスによる操作</span>
    </h3>
    <ul>
      <li>
        <span lang="en"><strong>Click</strong> to pause or unpause the video.</span>
        <span lang="ja"><strong>クリック</strong>：映像を一時停止／再開する。</span>
      </li>
      <li>
        <span lang="en"><strong>Double-Click</strong> to hide or show the video.</span>
        <span lang="ja"><strong>ダブルクリック</strong>：映像を隠す／再表示する。</span>
      </li>
      <li>
        <span lang="en"><strong>Drag</strong> to shift the video.</span>
        <span lang="ja"><strong>ドラッグ</strong>：映像の位置をずらす。</span>
      </li>
      <li>
        <span lang="en"><strong>Wheel Up/Down</strong> to enlarge or reduce the video.</span>
        <span lang="ja"><strong>ホイールを回す</strong>：映像を拡大／縮小する。</span>
      </li>
    </ul>
    <h3>
      <span lang="en">Use a Keyboard</span>
      <span lang="ja">キーボードによる操作</span>
    </h3>
    <ul>
      <li>
        <span lang="en">Press <strong>Space</strong> to pause or unpause the video.</span>
        <span lang="ja"><strong>スペースキー</strong>：映像を一時停止／再開する。</span>
      </li>
      <li>
        <span lang="en">Press <strong>Enter</strong> to hide the video.</span>
        <span lang="ja"><strong>エンターキー</strong>：映像を隠す。</span>
      </li>
      <li>
        <span lang="en">Press <strong>Esc</strong> to show the video.</span>
        <span lang="ja"><strong>エスケープキー</strong>：映像を再表示する。</span>
      </li>
      <li>
        <span lang="en">Press <strong>Up/Down/Left/Right</strong> to shift the video.</span>
        <span lang="ja"><strong>上下左右キー</strong>：映像の位置をずらす。</span>
      </li>
      <li>
        <span lang="en">Press <strong>PageUp/PageDown</strong> to enlarge or reduce the video.</span>
        <span lang="ja"><strong>ページアップ／ページダウンキー</strong>：映像を拡大／縮小する。</span>
      </li>
    </ul>
    <h2>
      <span lang="en">How to Change Settings</span>
      <span lang="ja">設定変更方法</span>
    </h2>
    <h2>
      <span lang="en">How to Install</span>
      <span lang="ja">インストール方法</span>
    </h2>
  </div>
</div>
<script>
  window.onload = e => main();
  const main = () => {
    const themeColors = {
      background1: 'rgb(53,54,58)',
      font1: 'rgb(242,242,242)',
      background2: 'rgb(242,242,242)',
      font2: 'rgb(158,158,158)',
      background3: 'rgb(242,242,242)',
      font3: 'rgb(53,54,58)'
    };
    const queryParser = new QueryParser();
    const magnifier = new Magnifier({
      fitMode: queryParser.getValue('fitMode', 'integer', 2),
      surplusWidth: 8,
      surplusHeight: 8,
      maxScale: queryParser.getValue('maxScale', 'integer', 5),
      fineness: queryParser.getValue('fineness', 'integer', 10),
      backgroundColor: queryParser.getValue('backgroundColor', 'string', '')
    });
    const shutter = (() => {
      const obj = new Shutter({
        showWait: queryParser.getValue('shutterWait', 'integer', 60000),
        startVisible: true,
        backgroundColor: themeColors.background2,
        color: themeColors.font2
      });
      obj.content = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          text-align: center;
          transform: scaleX(-1);
        `;
        elm.innerHTML = `
          <strong>
            <span lang="en">Anytime Mirror</span>
            <span lang="ja">いつでもミラー</span>
          </strong>
        `;
        return elm;
      })();
      obj.onShow = () => {
        webcam.stop();
        notifier.notify(`
          <span lang="en" class="pc">Double-Click or press Esc to show...</span>
          <span lang="en" class="sp">Double-Tap to show...</span>
          <span lang="ja" class="pc">ダブルクリック又はエスケープキーで再表示...</span>
          <span lang="ja" class="sp">ダブルタップで再表示...</span>
        `);
      };
      obj.onHide = () => {
        magnifier.update();
        webcam.restart();
        notifier.notify('');
      };
      return obj;
    })();
    const notifier = new Notifier({
      alignCenter: false,
      alignBottom: true,
      backgroundColor: themeColors.background1,
      color: themeColors.font1
    });
    const controller = (() => {
      const obj = new Controller({
        inputWait: queryParser.getValue('inputWait', 'integer', 250)
      });
      obj.isEnabled = false;
      obj.onClick = () => {
        if (shutter.isHidden) webcam.togglePause();
      };
      obj.onDoubleClick = () => shutter.toggleHide();
      obj.onDrag = (movementX, movementY) => {
        if (shutter.isHidden) magnifier.move(movementX, movementY, true);
      };
      obj.onDrop = () => {
        if (shutter.isHidden) magnifier.update();
      }
      obj.onScroll = deltaY => {
        if (shutter.isHidden) magnifier.magnify(deltaY)
      };
      obj.onKeyDown = keyCode => {
        if (keyCode == 0x20) { // 0x20: VK_SPACE
          if (shutter.isHidden) webcam.togglePause();
        } else if (keyCode == 0x0D) { // 0x0D: VK_RETURN
          shutter.show();
        } else  if (keyCode == 0x1B) { // 0x1B: VK_ESCAPE
          shutter.hide();
        } else if (keyCode == 0x26) { // 0x26: VK_UP
          if (shutter.isHidden) magnifier.move(0, -25);
        } else if (keyCode == 0x28) { // 0x28: VK_DOWN
          if (shutter.isHidden) magnifier.move(0, 25);
        } else if (keyCode == 0x25) { // 0x25: VK_LEFT
          if (shutter.isHidden) magnifier.move(-25, 0);
        } else if (keyCode == 0x27) { // 0x27: VK_RIGHT
          if (shutter.isHidden) magnifier.move(25, 0);
        } else if (keyCode == 0x21) { // 0x21: VK_PRIOR
          if (shutter.isHidden) magnifier.magnify(-100);
        } else if (keyCode == 0x22) { // 0x22: VK_NEXT
          if (shutter.isHidden) magnifier.magnify(100);
        }
      };
      obj.onAnyAction = () => {
        if (shutter.isHidden) shutter.resetShowTimer();
      };
      return obj;
    })();
    const menu = (() => {
      const obj = new Menu({alignRight: true});
      obj.isEnabled = false;
      obj.addItem('&#x24d8;', () => aboutThisAppDialog.show());
      obj.addItem('?', () => helpDialog.show());
      if (location.protocol == 'https:' && 'serviceWorker' in navigator) {
        obj.addItem('&#x27f3;', () => {
          if (! navigator.onLine) return;
          navigator.serviceWorker.getRegistration().then(registration => {
            registration && registration.unregister();
            location.reload();
          });
        });
      }
      return obj;
    })();
    const aboutThisAppDialog = (() => {
      const obj = new Dialog({
        backgroundColor: themeColors.background3,
        color: themeColors.font3
      });
      obj.title = `
        <strong>
          <span lang="en">About This App</span>
          <span lang="ja">このアプリについて</span>
        </strong>
      `;
      obj.content = document.querySelector('#about-this-app-content');
      obj.onShow = () => controller.isEnabled = false;
      obj.onHide = () => controller.isEnabled = true;
      return obj;
    })();
    const helpDialog = (() => {
      const obj = new Dialog({
        backgroundColor: themeColors.background3,
        color: themeColors.font3
      });
      obj.title = `
        <strong>
          <span lang="en">Help</span>
          <span lang="ja">ヘルプ</span>
        </strong>
      `;
      obj.content = document.querySelector('#help-content');
      obj.onShow = () => controller.isEnabled = false;
      obj.onHide = () => controller.isEnabled = true;
      return obj;
    })();
    const appContainer = (() => {
      const obj = new AppContainer({
        backgroundColor: themeColors.background1,
        color: themeColors.font1
      });
      obj.onVisibilityChange = () => magnifier.update();
      obj.onResize = () => magnifier.update(false, true);
      obj.appendChildren([
        magnifier.body,
        shutter.body,
        notifier.body,
        controller.body,
        menu.body,
        aboutThisAppDialog.body,
        helpDialog.body
      ]);
      return obj;
    })();
    document.body.appendChild(appContainer.body);
    const webcam = (() => {
      const obj = new Webcam({
        flip: queryParser.getValue('flip', 'boolean', true),
        grayscale: queryParser.getValue('grayscale', 'boolean', false)
      });
      obj.start(video => {
        magnifier.content = video;
        menu.isEnabled = true;
        controller.isEnabled = true;
        shutter.hide();
      });
      return obj;
    })();
  };
  class QueryParser {
    constructor({} = {}) {
      const values = {};
      const queryString = decodeURIComponent(location.search.slice(1));
      queryString.split('&').forEach(parameter => {
        let name, value;
        if (parameter.match(/=/)) {
          name = parameter.match(/^[^=]*/)[0].toLowerCase().trim();
          value = parameter.match(/=.*$/)[0].slice(1).trim();
        } else {
          name = parameter.toLowerCase().trim();
          value = 'true';
        }
        if (name) values[name] = value;
      });
      this._values = values;
    }
    getValue(name, type, defaultValue) {
      name = typeof name == 'string' ? name : '';
      type = typeof type == 'string' ? type : '';
      let value = this._values[name.toLowerCase().trim()];
      if (type == 'number') {
        value = Number(value);
        if (! Number.isFinite(value)) value = undefined;
      } else if (type == 'integer') {
        value = Number(value);
        if (! Number.isInteger(value)) value = undefined;
      } else if (type == 'boolean') {
        if (/^\s*true\s*$/i.test(value)) {
          value = true;
        } else if (/^\s*false\s*$/i.test(value)) {
          value = false;
        } else {
          value = undefined;
        }
      }
      if (value === undefined) value = defaultValue;
      return value;
    }
  }
  class AppContainer {
    constructor({backgroundColor, color} = {}) {
      backgroundColor = typeof backgroundColor == 'string' ? backgroundColor : '';
      color = typeof color == 'string' ? color : '';
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          overflow: hidden;
          box-sizing: border-box;
          background-color: ${backgroundColor};
          color: ${color};
          font-size: min(1rem, 5vmin);
          font-family: sans-serif;
          user-select: none;
          touch-action: manipulation;
        `;
        elm.addEventListener('contextmenu', e => {
          e.preventDefault();
        });
        elm.addEventListener('touchstart', e => {
          if (e.touches.length == 1) return;
          e.preventDefault();
        }, {capture: true});
        elm.addEventListener('touchmove', e => {
          if (e.touches.length == 1) return;
          e.preventDefault();
        }, {capture: true});
        return elm;
      })();
      document.addEventListener('visibilitychange', e => {
        this._onVisibilityChange();
      });
      const monitorResize = (lastWidth, lastHeight, countDown) => {
        const currentWidth = body.clientWidth;
        const currentHeight = body.clientHeight;
        if (currentWidth != lastWidth || currentHeight != lastHeight) {
          countDown = 5;
        } else if (countDown-- && countDown == 0) {
          this._onResize(currentWidth, currentHeight);
        }
        window.setTimeout(() => {
          monitorResize(currentWidth, currentHeight, countDown);
        }, 200);
      };
      monitorResize(body.clientWidth, body.clientHeight, 0);
      this._body = body;
      this._onVisibilityChange = () => {};
      this._onResize = () => {};
    }
    get body() {
      return this._body;
    }
    set onVisibilityChange(handler) {
      if (typeof handler != 'function') return false;
      this._onVisibilityChange = handler;
    }
    set onResize(handler) {
      if (typeof handler != 'function') return false;
      this._onResize = handler;
    }
    appendChildren(children) {
      if (! Array.isArray(children)) return false;
      children.forEach(child => {
        if (! child instanceof HTMLElement) return;
        this._body.appendChild(child);
      });
    }
  }
  class Magnifier {
    constructor({fitMode, surplusWidth, surplusHeight, maxScale, fineness, backgroundColor} = {}) {
      fitMode = Number.isInteger(fitMode) ? fitMode : 0;
      surplusWidth = Number.isInteger(surplusWidth) ? Math.max(0, surplusWidth) : 0;
      surplusHeight = Number.isInteger(surplusHeight) ? Math.max(0, surplusHeight) : 0;
      maxScale = Number.isInteger(maxScale) ? Math.max(1, Math.min(50, maxScale)) : 5;
      fineness = Number.isInteger(fineness) ? Math.max(1, Math.min(100, fineness)) : 10;
      backgroundColor = typeof backgroundColor == 'string' ? backgroundColor : '';
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          overflow: hidden;
          box-sizing: border-box;
          background-color: ${backgroundColor};
        `;
        return elm;
      })();
      const lense = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          position: absolute;
          max-width: 100%;
          max-height: 100%;
          overflow: hidden;
          box-sizing: border-box;
          justify-content: center;
          align-items: center;
        `;
        return elm;
      })();
      body.appendChild(lense);
      this._body = body;
      this._lense = lense;
      this._content = null;
      this._fitMode = fitMode;
      this._surplusWidth = surplusWidth;
      this._surplusHeight = surplusHeight;
      this._maxScale = maxScale;
      this._fineness = fineness;
    }
    get body() {
      return this._body;
    }
    set content(content) {
      if (! content instanceof HTMLElement) return;
      if (this._lense.children.length) {
        this._lense.children.forEach(child => child.remove());
      }
      const contentWrapper = document.createElement('div');
      contentWrapper.appendChild(content);
      this._lense.appendChild(contentWrapper);
      this._content = content;
      this.update(false, true);
    }
    update(anchor, reset) {
      anchor = typeof anchor == 'boolean' ? anchor : false;
      reset = typeof reset == 'boolean' ? reset : false;
      if (! this._content) return false;
      if (reset) {
        const bodyWidth = this._body.offsetWidth;
        const bodyHeight = this._body.offsetHeight;
        const contentWidth = this._content.offsetWidth;
        const contentHeight = this._content.offsetHeight;
        let fitToWidth, fitToHeight;
        const bodyWidthToHeight = bodyWidth / Math.max(1, bodyHeight);
        const contentWidthToHeight = contentWidth / Math.max(1, contentHeight);
        if (this._fitMode == 1) { // 1: Contain
          fitToWidth = contentWidthToHeight > bodyWidthToHeight;
          fitToHeight = ! fitToWidth;
        } else if (this._fitMode == 2) { // 2: Cover
          fitToWidth = contentWidthToHeight < bodyWidthToHeight;
          fitToHeight = ! fitToWidth;
        } else if (this._fitMode == 3) { // 3: Fill
          [fitToWidth, fitToHeight] = [true, true];
        } else if (this._fitMode == 4) { // 4: Width
          [fitToWidth, fitToHeight] = [true, false];
        } else if (this._fitMode == 5) { // 5: Height
          [fitToWidth, fitToHeight] = [false, true];
        } else { // 0: None
          [fitToWidth, fitToHeight] = [false, false];
        }
        this._content.style.width = fitToWidth ? `${bodyWidth + this._surplusWidth}px` : '';
        this._content.style.height = fitToHeight ? `${bodyHeight + this._surplusHeight}px` : '';
        this._scale = 1;
        this._offsetX = (this._body.offsetWidth - this._lense.offsetWidth) / 2;
        this._offsetY = (this._body.offsetHeight - this._lense.offsetHeight) / 2;
        this._movementX = 0;
        this._movementY = 0;
      }
      if (! anchor) {
        const bodyWidth = this._body.offsetWidth;
        const contentWidth = this._lense.offsetWidth * this._scale;
        if (contentWidth < bodyWidth) {
          this._movementX = 0;
        } else {
          const minMovementX = (bodyWidth - contentWidth) / 2;
          const maxMovementX = (contentWidth - bodyWidth) / 2;
          this._movementX = Math.max(minMovementX, Math.min(maxMovementX, this._movementX));
        }
        const bodyHeight = this._body.offsetHeight;
        const contentHeight = this._lense.offsetHeight * this._scale;
        if (contentHeight < bodyHeight) {
          this._movementY = 0;
        } else {
          const minMovementY = (bodyHeight - contentHeight) / 2;
          const maxMovementY = (contentHeight - bodyHeight) / 2;
          this._movementY = Math.max(minMovementY, Math.min(maxMovementY, this._movementY));
        }
      }
      this._lense.style.transform = `scale(${this._scale})`;
      this._lense.style.marginLeft = `${this._offsetX + this._movementX}px`;
      this._lense.style.marginTop = `${this._offsetY + this._movementY}px`;
    }
    magnify(amount) {
      amount = Number.isFinite(amount) ? amount : 0;
      if (! this._content) return false;
      this._scale += amount * -0.01 / this._fineness;
      this._scale = Math.max(1, Math.min(this._maxScale, this._scale));
      this.update();
    }
    move(movementX, movementY, anchor) {
      movementX = Number.isFinite(movementX) ? movementX : 0;
      movementY = Number.isFinite(movementY) ? movementY : 0;
      anchor = typeof anchor == 'boolean' ? anchor : false;
      if (! this._content) return false;
      this._movementX += movementX;
      this._movementY += movementY;
      this.update(anchor);
    }
  }
  class Shutter {
    constructor({showWait, startVisible, backgroundColor, color, transition} = {}) {
      showWait = Number.isInteger(showWait) ? Math.max(0, Math.min(3600000, showWait)) : 30000;
      startVisible = typeof startVisible == 'boolean' ? startVisible : false;
      backgroundColor = typeof backgroundColor == 'string' ? backgroundColor : 'rgb(255,255,255)';
      color = typeof color == 'string' ? color : 'rgb(0,0,0)';
      transition = Number.isInteger(transition) ? Math.max(0, Math.min(2000, transition)) : 500;
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          visibility: ${startVisible ? 'visible' : 'hidden'};
          opacity: ${startVisible ? '1' : '0'};
          position: absolute;
          top: 0;
          left: 0;
          z-index: 2147483647;
          width: 100%;
          height: 100%;
          box-sizing: border-box;
          background-color: ${backgroundColor};
          color: ${color};
          justify-content: center;
          align-items: center;
          transition: ${transition}ms;
          user-select: none;
        `;
        return elm;
      })();
      const contentWrapper = document.createElement('div');
      body.appendChild(contentWrapper);
      this._body = body;
      this._contentWrapper = contentWrapper;
      this._showWait = showWait;
      this._showTimeoutId = null;
      this._onShow = () => {};
      this._onHide = () => {};
      this.resetShowTimer();
    }
    get body() {
      return this._body;
    }
    get isHidden() {
      return this._body.style.visibility == 'hidden';
    }
    set content(content) {
      if (! content instanceof HTMLElement) return;
      if (this._contentWrapper.children.length) {
        this._contentWrapper.children.forEach(child => child.remove());
      }
      this._contentWrapper.appendChild(content);
    }
    set onShow(handler) {
      if (typeof handler != 'function') return;
      this._onShow = handler;
    }
    set onHide(handler) {
      if (typeof handler != 'function') return;
      this._onHide = handler;
    }
    resetShowTimer() {
      window.clearTimeout(this._showTimeoutId);
      if (! this.isHidden) return false;
      if (this._showWait == 0) return false;
      this._showTimeoutId = window.setTimeout(() => {
        this._showTimeoutId = null;
        this.show();
      }, this._showWait);
    }
    show() {
      this._body.style.visibility = 'visible';
      this._body.style.opacity = '1';
      this._onShow();
    }
    hide() {
      this._body.style.opacity = '0';
      this._body.style.visibility = 'hidden';
      this._onHide();
      this.resetShowTimer();
    }
    toggleHide() {
      this.isHidden ? this.show() : this.hide();
    }
  }
  class Notifier {
    constructor({alignCenter, alignBottom, backgroundColor, color, transition} = {}) {
      alignCenter = typeof alignCenter == 'boolean' ? alignCenter : false;
      alignBottom = typeof alignBottom == 'boolean' ? alignBottom : false;
      backgroundColor = typeof backgroundColor == 'string' ? backgroundColor : 'rgba(0,0,0,.6)';
      color = typeof color == 'string' ? color : 'rgb(255,255,255)';
      transition = Number.isInteger(transition) ? Math.max(0, Math.min(2000, transition)) : 500;
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          opacity: 0;
          position: absolute;
          top: ${alignBottom ? '' : '0'};
          bottom: ${alignBottom ? '0' : ''};
          left: 0;
          z-index: 2147483647;
          width: 100%;
          height: 4em;
          padding: 0 1em;
          box-sizing: border-box;
          background-color: ${backgroundColor};
          color: ${color};
          justify-content: ${alignCenter ? 'center' : ''};
          align-items: center;
          transition: ${transition}ms;
          user-select: none;
          pointer-events: none;
        `;
        return elm;
      })();
      this._body = body;
      this._transition = transition;
      this._text = '';
    }
    get body() {
      return this._body;
    }
    notify(text) {
      text = typeof text == 'string' ? text : '';
      this._body.style.opacity = text ? '1' : '0';
      this._body.innerHTML = text;
    }
  }
  class Controller {
    constructor({enableKeyboard, enableMouse, enableTouch, inputWait} = {}) {
      enableKeyboard = typeof enableKeyboard == 'boolean' ? enableKeyboard : true;
      enableMouse = typeof enableMouse == 'boolean' ? enableMouse : true;
      enableTouch = typeof enableTouch == 'boolean' ? enableTouch : true;
      inputWait = Number.isInteger(inputWait) ? Math.max(100, Math.min(1000, inputWait)) : 250;
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          z-index: 2147483647;
          width: 100%;
          height: 100%;
          box-sizing: border-box;
          outline: none;
        `;
        return elm;
      })();
      if (enableKeyboard) {
        body.tabIndex = 0;
        body.focus();
        body.addEventListener('blur', e => {
          e.preventDefault();
          e.stopPropagation();
          body.focus();
        });
        body.addEventListener('keydown', e => {
          if (body.style.display == 'none') return;
          if (e.ctrlKey || e.altKey || e.metaKey) return;
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          this._onKeyDown(e.keyCode);
        });
      }
      if (enableMouse) {
        let clickTimeoutId = null;
        let clickCount = 0;
        let isDragging = false;
        let lastButton = null;
        body.addEventListener('mousedown', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          window.clearTimeout(clickTimeoutId);
          clickTimeoutId = null;
          if (e.button == lastButton) {
            clickCount++;
          } else {
            clickCount = 1;
            lastButton = e.button;
            if (isDragging) this._onDrop();
          }
          isDragging = false;
        });
        body.addEventListener('mousemove', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          if (e.buttons & 1) { // 1: Primary button
            if (clickCount >= 1) isDragging = true;
          } else {
            if (isDragging) this._onDrop();
            isDragging = false;
          }
          clickCount = 0;
          if (isDragging) {
            this._onDrag(e.movementX, e.movementY);
          }
        });
        body.addEventListener('mouseup', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          if (isDragging) {
            if (e.button == 0) { // 0: Main button
              this._onDrop();
              isDragging = false;
            }
          } else {
            clickTimeoutId = window.setTimeout(() => {
              clickTimeoutId = null;
              if (lastButton == 0) { // 0: Main button
                if (clickCount == 1) this._onClick();
                if (clickCount == 2) this._onDoubleClick();
              } else if (lastButton == 1) { // 1: Auxiliary button
                if (clickCount == 1) this._onMiddleClick();
              } else if (lastButton == 2) { // 2: Secondary button
                if (clickCount == 1) this._onRightClick();
              }
              clickCount = 0;
            }, inputWait);
          }
        });
        body.addEventListener('wheel', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          this._onScroll(e.deltaY);
        });
      }
      if (enableTouch) {
        let tapTimeoutId = null;
        let touchCount = 0;
        let isDragging = false;
        let isScrolling = false;
        let lastTouch = null;
        body.addEventListener('touchstart', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          window.clearTimeout(tapTimeoutId);
          if (e.touches.length == 1) {
            touchCount++;
            lastTouch = e.touches[0];
          } else {
            touchCount = 0;
            if (isDragging) this._onDrop();
          }
          isDragging = false;
          isScrolling = false;
        });
        body.addEventListener('touchmove', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          if (touchCount == 1) isDragging = true;
          if (touchCount >= 2) isScrolling = true;
          touchCount = 0;
          let currentTouch = e.touches[0];
          if (isDragging) {
            let movementX = currentTouch.screenX - lastTouch.screenX;
            let movementY = currentTouch.screenY - lastTouch.screenY;
            this._onDrag(movementX, movementY);
          } else if (isScrolling) {
            let deltaY = (lastTouch.screenY - currentTouch.screenY) * 10;
            this._onScroll(deltaY);
          }
          lastTouch = currentTouch;
        });
        body.addEventListener('touchend', e => {
          e.preventDefault();
          e.stopPropagation();
          this._onAnyAction();
          if (isDragging) {
            this._onDrop();
          } else {
            tapTimeoutId = window.setTimeout(() => {
              tapTimeoutId = null;
              if (touchCount == 1) this._onClick();
              if (touchCount == 2) this._onDoubleClick();
              touchCount = 0;
            }, inputWait);
          }
        });
      }
      this._body = body;
      this._onDrag = () => {};
      this._onDrop = () => {};
      this._onClick = () => {};
      this._onDoubleClick = () => {};
      this._onMiddleClick = () => {};
      this._onRightClick = () => {};
      this._onScroll = () => {};
      this._onKeyDown = () => {};
      this._onAnyAction = () => {};
      this._enableKeyboard = enableKeyboard;
    }
    get body() {
      return this._body;
    }
    get isEnabled() {
      return this._body.style.display == 'block';
    }
    set isEnabled(boolean) {
      if (typeof boolean != 'boolean') return;
      if (boolean) {
        this._body.style.display = 'block';
        if (this._enableKeyboard) {
          this._body.style.tabIndex = 0;
          this._body.focus();
        }
      } else {
        this._body.style.display = 'none';
        if (this._enableKeyboard) {
          this._body.blur();
          this._body.tabIndex = -1;
        }
      }
    }
    set onDrag(handler) {
      if (typeof handler != 'function') return;
      this._onDrag = handler;
    }
    set onDrop(handler) {
      if (typeof handler != 'function') return;
      this._onDrop = handler;
    }
    set onClick(handler) {
      if (typeof handler != 'function') return;
      this._onClick = handler;
    }
    set onDoubleClick(handler) {
      if (typeof handler != 'function') return;
      this._onDoubleClick = handler;
    }
    set onMiddleClick(handler) {
      if (typeof handler != 'function') return;
      this._onMiddleClick = handler;
    }
    set onRightClick(handler) {
      if (typeof handler != 'function') return;
      this._onRightClick = handler;
    }
    set onScroll(handler) {
      if (typeof handler != 'function') return;
      this._onScroll = handler;
    }
    set onKeyDown(handler) {
      if (typeof handler != 'function') return;
      this._onKeyDown = handler;
    }
    set onAnyAction(handler) {
      if (typeof handler != 'function') return;
      this._onAnyAction = handler;
    }
  }
  class Menu {
    constructor({alignRight, alignBottom, color, shadowColor} = {}) {
      alignRight = typeof alignRight == 'boolean' ? alignRight : false;
      alignBottom = typeof alignBottom == 'boolean' ? alignBottom : false;
      color = typeof color == 'string' ? color : 'rgb(255,255,255)';
      shadowColor = typeof shadowColor == 'string' ? shadowColor : 'rgb(0,0,0)';
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          position: absolute;
          top: ${!alignBottom ? '0' : ''};
          bottom: ${alignBottom ? '0' : ''};
          left: 0;
          z-index: 2147483647;
          width: 100%;
          height: 3rem;
          padding: 0 1.5rem;
          box-sizing: border-box;
          color: ${color};
          font-weight: bold;
          font-size: 1.5rem;
          justify-content: ${alignRight ? 'flex-end' : 'flex-start'};
          align-items: center;
          pointer-events: none;
        `;
        return elm;
      })();
      this._body = body;
      this._alignRight = alignRight;
      this._shadowColor = shadowColor;
      this._isEnabled = true;
    }
    get body() {
      return this._body;
    }
    get isEnabled() {
      return this._isEnabled;
    }
    set isEnabled(boolean) {
      if (typeof boolean != 'boolean') return;
      this._isEnabled = boolean;
    }
    addItem(text, onClick) {
      text = typeof text == 'string' ? text : '';
      onClick = typeof onClick == 'function' ? onClick : () => {};
      const item = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          margin-right: ${this._alignRight ? '' : '1.5em'};
          margin-left: ${this._alignRight ? '1.5em' : ''};
          text-shadow:
            0 -1px ${this._shadowColor}, 1px 0 ${this._shadowColor},
            0 1px ${this._shadowColor}, -1px 0 ${this._shadowColor},
            -1px -1px ${this._shadowColor}, 1px -1px ${this._shadowColor},
            1px 1px ${this._shadowColor}, -1px 1px ${this._shadowColor};
          user-select: none;
          pointer-events: auto;
        `;
        elm.innerHTML = text || '*';
        elm.addEventListener('click', e => {
          if (! this._isEnabled) return;
          onClick();
        });
        return elm;
      })();
      this._body.appendChild(item);
    }
  }
  class Dialog {
    constructor({startVisible, backgroundColor, color, curtainOpacity, transition} = {}) {
      startVisible = typeof startVisible == 'boolean' ? startVisible : false;
      backgroundColor = typeof backgroundColor == 'string' ? backgroundColor : 'rgb(255,255,255)';
      color = typeof color == 'string' ? color : 'rgb(0,0,0)';
      curtainOpacity = Number.isFinite(curtainOpacity) ? Math.max(0, Math.min(1, curtainOpacity)) : 0.7;
      transition = Number.isInteger(transition) ? Math.max(0, Math.min(3000, transition)) : 500;
      const body = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          visibility: ${startVisible ? 'visible' : 'hidden'};
          opacity: ${startVisible ? '1' : '0'};
          position: absolute;
          top: 0;
          left: 0;
          z-index: 2147483647;
          width: 100%;
          height: 100%;
          box-sizing: border-box;
          justify-content: center;
          align-items: center;
          transition: ${transition}ms;
        `;
        return elm;
      })();
      const curtain = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          box-sizing: border-box;
          background-color: rgba(0,0,0,${curtainOpacity});
        `;
        elm.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          if (e.button == 0) this.hide(); // 0: Main button
        });
        return elm;
      })();
      const panel = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: relative;
          width: calc(100% - 20vmin);
          height: calc(100% - 20vmin);
          box-sizing: border-box;
          background-color: ${backgroundColor};
          color: ${color};
        `;
        return elm;
      })();
      const titleBar = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          display: flex;
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 3em;
          box-sizing: border-box;
          font-weight: bold;
          justify-content: center;
          align-items: center;
          user-select: none;
        `;
        return elm;
      })();
      const contentWrapper = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          bottom: 1em;
          left: 0;
          width: 100%;
          height: calc(100% - 3em - 1em);
          padding: 1em 2em;
          overflow-y: auto;
          box-sizing: border-box;
        `;
        return elm;
      })();
      const closeButton = (() => {
        const elm = document.createElement('div');
        elm.style.cssText = `
          position: absolute;
          top: .5em;
          right: 1em;
          font-weight: bold;
          user-select: none;
        `;
        elm.innerHTML = '&#x2715';
        elm.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          if (e.button == 0) this.hide(); // 0: Main button
        });
        return elm;
      })();
      body.appendChild(curtain);
      body.appendChild(panel);
      panel.appendChild(titleBar);
      panel.appendChild(contentWrapper);
      panel.appendChild(closeButton);
      this._body = body;
      this._titleBar = titleBar;
      this._contentWrapper = contentWrapper;
      this._onShow = () => {};
      this._onHide = () => {};
    }
    get body() {
      return this._body;
    }
    get isHidden() {
      return this._body.style.visibility == 'hidden';
    }
    set title(title) {
      if (typeof title != 'string') return;
      this._titleBar.innerHTML = title;
    }
    set content(content) {
      if (! content instanceof HTMLElement) return;
      if (this._contentWrapper.children.length) {
        this._contentWrapper.children.forEach(child => child.remove());
      }
      this._contentWrapper.appendChild(content);
    }
    set onShow(handler) {
      if (typeof handler != 'function') return;
      this._onShow = handler;
    }
    set onHide(handler) {
      if (typeof handler != 'function') return;
      this._onHide = handler;
    }
    show() {
      if (! this.isHidden) return;
      this._body.style.visibility = 'visible';
      this._body.style.opacity = '1';
      this._onShow();
    }
    hide() {
      if (this.isHidden) return;
      this._body.style.opacity = '0';
      this._body.style.visibility = 'hidden';
      this._onHide();
    }
  }
  class Webcam {
    constructor({flip, grayscale} = {}) {
      flip = typeof flip == 'boolean' ? flip : false;
      grayscale = typeof grayscale == 'boolean' ? grayscale : false;
      const video = (() => {
        const elm = document.createElement('video');
        elm.style.cssText = `
          transform: ${flip ? 'scaleX(-1)' : ''};
          filter: ${grayscale ? 'grayscale(100%)' : ''};
        `;
        elm.autoplay = true;
        elm.muted = true;
        elm.setAttribute('playsinline', null);
        return elm;
      })();
      this._video = video;
    }
    start(callback) {
      if (typeof callback != 'function') return false;
      this._video.addEventListener('loadedmetadata', e => callback(this._video));
      navigator.mediaDevices.getUserMedia({
        video: {facingMode: 'user'},
        audio: false
      }).then(stream => {
        this._video.srcObject = stream;
        this._isStarted = true;
      });
    }
    stop() {
      if (! this._isStarted) return false;
      this._video.pause();
      this._video.srcObject.getTracks().forEach(track => track.enabled = false);
    }
    restart() {
      if (! this._isStarted) return false;
      this._video.play();
      this._video.srcObject.getTracks().forEach(track => track.enabled = true);
    }
    pause() {
      if (! this._isStarted) return false;
      this._video.pause()
    }
    unpause() {
      if (! this._isStarted) return false;
      this._video.play();
    }
    togglePause() {
      if (! this._isStarted) return false;
      this._video.paused ? this._video.play() : this._video.pause();
    }
  }
</script>
